@page "/calendar-agent"
@using System.Globalization
@using System.Text.RegularExpressions
@inject BlazorApp2.Services.AiService Ai

<h3>Schedule Assistant (Agentic AI)</h3>

<div class="mb-3">
    <label class="form-label">What do you want to schedule?</label>
    <textarea class="form-control" rows="3" @bind="UserRequest"
              placeholder="E.g., Help me schedule a meeting with my group next week, 1 hour."></textarea>
</div>

<div class="mb-3">
    <label class="form-label">Preferred date range (optional)</label>
    <input class="form-control" @bind="DateRange"
           placeholder="E.g., 16â€“20 Dec 2026, afternoon" />
</div>

<button class="btn btn-primary" @onclick="GenerateOptions" disabled="@IsBusy">
    @(IsBusy ? "Generating..." : "Suggest 3 Time Options")
</button>

@if (!string.IsNullOrWhiteSpace(AiRaw))
{
    <hr />
    <h5>AI Planning Output (3 Options)</h5>
    <pre class="p-3 border rounded bg-light">@AiRaw</pre>
}

@if (Options.Count > 0)
{
    <hr />
    <h5>Pick one slot</h5>

    <div class="row g-3">
        @foreach (var opt in Options)
        {
            <div class="col-12 col-md-6 col-lg-4">
                <div class="card h-100">
                    <div class="card-body">
                        <h6 class="card-title">@opt.Label</h6>
                        <div><b>Title:</b> @opt.Title</div>
                        <div><b>Start:</b> @opt.StartLocal.ToString("yyyy-MM-dd HH:mm")</div>
                        <div><b>End:</b> @opt.EndLocal.ToString("yyyy-MM-dd HH:mm")</div>
                        @if (!string.IsNullOrWhiteSpace(opt.Location))
                        {
                            <div><b>Location:</b> @opt.Location</div>
                        }
                        @if (!string.IsNullOrWhiteSpace(opt.Description))
                        {
                            <div class="mt-2"><b>Notes:</b> @opt.Description</div>
                        }
                    </div>
                    <div class="card-footer bg-transparent border-0 pb-3">
                        <a class="btn btn-success w-100" href="@opt.GoogleUrl" target="_blank">
                            Add Option to Google Calendar
                        </a>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    private string UserRequest = "";
    private string DateRange = "";
    private bool IsBusy = false;

    private string AiRaw = "";
    private List<EventOption> Options = new();

    private async Task GenerateOptions()
    {
        IsBusy = true;
        AiRaw = "";
        Options.Clear();

        // 1. Get the current time so the AI knows "Today"
        var now = DateTime.Now;
        var currentContext = $"Today is {now:dddd, MMMM dd, yyyy} (Time: {now:HH:mm}). Current Year is {now.Year}.";

        // Agentic prompt: always propose 3 options.
        // If user gave exact date/time, Option 1 should match it; Options 2/3 are reasonable alternatives.
        var prompt = $@"
You are a scheduling agent.

Task:
- Propose THREE possible time options for ONE meeting/event based on the user's request.
- If the user provided an exact date/time, Option 1 MUST match that exact time.
- If time is not provided, suggest 3 realistic time slots.
- Keep all options within the user's preferred date range if provided.
- Use local time.
- Return ONLY plain text. DO NOT use Markdown bolding (**), italics, or code blocks.
- DO NOT add conversational filler like 'Here are the options'.
- If the user does not specify a year, MUST assume the year is {now.Year}.

Return ONLY in this exact format (labels and order must match):

Option 1
Title: ...
Start (local): YYYY-MM-DD HH:MM
End (local): YYYY-MM-DD HH:MM
Location: ...
Description: ...

Option 2
Title: ...
Start (local): YYYY-MM-DD HH:MM
End (local): YYYY-MM-DD HH:MM
Location: ...
Description: ...

Option 3
Title: ...
Start (local): YYYY-MM-DD HH:MM
End (local): YYYY-MM-DD HH:MM
Location: ...
Description: ...

User request: {UserRequest}
Preferred date range (optional): {DateRange}
";

        AiRaw = await Ai.AskAsync(prompt);

        var parsed = ParseThreeOptions(AiRaw);
        if (parsed.Count > 0)
        {
            // build Google Calendar URL for each option
            foreach (var o in parsed)
            {
                o.GoogleUrl = BuildGoogleCalendarUrl(o);
            }
            Options = parsed;
        }

        IsBusy = false;
    }

    // ===== Parsing =====

    private static List<EventOption> ParseThreeOptions(string text)
    {
        var results = new List<EventOption>();

        // 1. Normalize the text to remove Markdown bolding/headers so Regex can find "Option 1"
        // This turns "**Option 1**" or "## Option 1" into just "Option 1"
        var cleanText = Regex.Replace(text, @"[*#]", "");

        // 2. Split using a Regex that looks for "Option 1", "Option 2", etc.
        // We use "Split" to break the text into chunks.
        var pattern = @"(?im)^\s*(Option\s+[123])[:.]?\s*$";
        var blocks = Regex.Split(cleanText, pattern)
                          .Where(s => !string.IsNullOrWhiteSpace(s))
                          .ToList();

        // 3. Robust Loop: Don't assume index 0 is "Option 1".
        // We scan the list. If we find "Option X", the NEXT item is the body.
        for (int i = 0; i < blocks.Count - 1; i++)
        {
            var potentialLabel = blocks[i].Trim();

            // Check if this block is actually a label (e.g., "Option 1")
            if (Regex.IsMatch(potentialLabel, @"^Option\s+[123]$", RegexOptions.IgnoreCase))
            {
                var body = blocks[i + 1]; // The text following the label

                var title = ExtractLine(body, "Title:");
                var startStr = ExtractLine(body, "Start (local):");
                var endStr = ExtractLine(body, "End (local):");
                var location = ExtractLine(body, "Location:");
                var desc = ExtractLine(body, "Description:");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(startStr))
                    continue;

                // 4. Flexible Date Parsing (Fixes the exact format crash)
                if (!DateTime.TryParse(startStr, CultureInfo.InvariantCulture, DateTimeStyles.None, out var startLocal))
                    continue;

                // Try parse end time, or default to 1 hour later
                if (!DateTime.TryParse(endStr, CultureInfo.InvariantCulture, DateTimeStyles.None, out var endLocal))
                    endLocal = startLocal.AddHours(1);

                if (endLocal <= startLocal) endLocal = startLocal.AddHours(1);

                results.Add(new EventOption
                {
                    Label = potentialLabel,
                    Title = title.Trim(),
                    StartLocal = startLocal,
                    EndLocal = endLocal,
                    Location = (location ?? "").Trim(),
                    Description = (desc ?? "").Trim()
                });

                // Skip the body block in the next iteration
                i++;
            }
        }

        return results;
    }

    private static string ExtractLine(string text, string label)
    {
        // Matches "Title:", "**Title**:", "Title :", etc.
        // The [*\s]* part ignores bolding asterisks and spaces around the label
        var pattern = $@"(?im)^\s*[*]*{Regex.Escape(label).Replace(":", "")}[*]*[:]*\s*(.+)$";
        var match = Regex.Match(text, pattern);
        return match.Success ? match.Groups[1].Value.Trim() : "";
    }

    // ===== Google Calendar URL builder =====

    private static string BuildGoogleCalendarUrl(EventOption evt)
    {
        // Convert local -> UTC for Google dates
        var startUtc = evt.StartLocal.ToUniversalTime();
        var endUtc = evt.EndLocal.ToUniversalTime();
        var dates = $"{startUtc:yyyyMMdd'T'HHmmss'Z'}/{endUtc:yyyyMMdd'T'HHmmss'Z'}";

        string text = Uri.EscapeDataString(evt.Title);
        string details = Uri.EscapeDataString(evt.Description);
        string location = Uri.EscapeDataString(evt.Location);

        return $"https://calendar.google.com/calendar/render?action=TEMPLATE&text={text}&dates={dates}&details={details}&location={location}";
    }

    private class EventOption
    {
        public string Label { get; set; } = "";
        public string Title { get; set; } = "";
        public DateTime StartLocal { get; set; }
        public DateTime EndLocal { get; set; }
        public string Location { get; set; } = "";
        public string Description { get; set; } = "";
        public string GoogleUrl { get; set; } = "";
    }
}
